# 11/12/2012 Hans Vangheluwe## GUIapplication_main.py## Usage: python GUIapplication_main.py [numWindows]##        The optional command-line argument numWindows gives the number of toplevel windows#        to open when the application starts.#        If no such argument is given, numWindows defaults to 1.##        Note that in principle, this could also default to 0. #        In that case, no windows would be shown. The creation of a window #        for the user to interact with can be triggered by the following#        - a timeout in the main application's behaviour Statechart#        - a signal (interrupt) received and handled by the main application#        - an event received via the network -- see (*)## A (test) framework for Tkinter GUIs.# This should serve as a basis for GUIs whose behaviour is modelled using Class Diagrams + Statecharts.## The applications consists of a number of Toplevel windows.# The overall application keeps control over all windows, including creation and deletion.# This means that the main application will be notified if a single window gets closed for example.## The application responds to two types of events beyond the application-specific GUI events# such as keypress and mouse events:# - signals (such as SIGHUP) from the Operating System to the application's process# - Window Manager events (currently only, closing a window)## TODO (*): the framework should also implement a network interface allowing#       events to be sent to and received from a network over an appropriate transport such as TCP/IP. #       Sending/receiving must be non-blocking (a-synchronous). Networking must be properly#       interleaved with UI (Tk) event handling.import sysimport timeimport signalimport Tkinter # import the UI application logic which will run inside a Toplevel window# from ToplevelApplicationBehaviour import ToplevelApplicationBehaviour# TODO: to test 100% encapsulation: #  1. should be able to instantiate GUIapplication multiple times in this same application.#     Each of these GUIapplication instances will start its own instance of Tk, so this may not#     work and GUIapplication may have to be a singleton. If multiple GUIapplication#     instances can be created, these should not interfere with one another.#  2. should be able to instantiate multiple toplevel windows, running #     the same application logic ToplevelApplicationBehaviour inside each such toplevel window.#     For these not to interfere with each other, they should not access the same #     "global" data, unless this is intended.class TopLevelWindow(Tkinter.Toplevel):  # TopLevelWindow.topLevelWindows is a class variable   # (i.e., globally unique for all TopLevelWindow instances)  # which keeps track of all toplevel windows.  # It is implemented as a dictionary with toplevel windows as keys and  # their names as data  topLevelWindows = {}  def __init__(self,              master=None,              height=30, width=70,               title="Anonymous Toplevel Window",              behaviour = None # compiled behaviour Statechart              ):    # initialize superclass    Tkinter.Toplevel.__init__(self, master)    # the Toplevel window's parent: the Tk root    self.window_master = master    # inital height and width of created window    self.window_height = height     self.window_width  = width    # not resizable    #self.resizable(width="NO", height="NO")    # TODO: allow resizable, but then update     #       height and width whenever changed (with get/set methods)    # the window's title    self.window_title  = title    self.title(self.window_title)    # register callback for what to do when the window is closed    # from the Window Manager    self.protocol("WM_DELETE_WINDOW", self.window_close)    # add this new window to the global topLevelWindows dictionary    TopLevelWindow.topLevelWindows[self] = self.window_title  def wm_window_close(self):    print 'Window "%s" was closed (by Window Manager)' % self.window_title    self.window_close(self)  def window_close(self):    print 'Window "%s" was closed' % self.window_title    # we may wish to put more cleanup actions here,     # before the Toplevel window gets destroyed    # remove this window from the topLevelWindows dictionary    del TopLevelWindow.topLevelWindows[self]     # actually destroy the Toplevel window      self.destroy()     # if no more Toplevel windows remain (i.e., dictionary is empty),     # close the entire application    if not TopLevelWindow.topLevelWindows:       print 'Closing entire application as now windows are left'      sys.exit(0)    # TODO: this should be left to the behaviour Statechart of the entire application,    #       not to a single TopLevelWindow. This will be done by sending it an appropriate event.class GUIapplicationStore:  def __init__(self, parent=None):    self.parent = parent    # put attributes here which are global to the entire GUIapplication instance    #class GUIapplication:  def __init__(self, commandLineArguments):    self.commandLineArguments = commandLineArguments    self.commandName = self.commandLineArguments[0]    self.progName = self.commandName.split('.')[0]    if len(commandLineArguments) == 1: # if no command line argument given       self.numWindows = 1      else:                             # one argument given: initial number of windows       self.numWindows = int(self.commandLineArguments[1])    self.store = GUIapplicationStore(parent=self)#    self.behaviour = ApplicationBehaviour() # the behaviour of the main application#    self.behaviour.event("start", self.store)    # register signal handler for application-level SIGINT     # (from <Ctrl-C> or "kill -s INT <process ID>")    signal.signal(signal.SIGINT, self.SIGINT_signal_handler)    # TODO: check which event is generated by Ctrl-C inside a Toplevel window    # and how to catch it (and send it to that Toplevel window's Statechart)    # This, as opposed to SIGINT to the application's process which is caught here    # TODO: check whether a signal handler can be registered more than once    # may need to put this in try: catch: in case GUIapplication is instantiated more than once    self.root = Tkinter.Tk()    # make the Tk root window invisible so it is not special.    # All Toplevel windows are then equivalent and users only interact with Toplevel windows.    self.root.withdraw()    for window_nr in range(self.numWindows):      topLevelWindow = TopLevelWindow(master=self.root,                                       title=self.progName+' '+str(window_nr),                                      behaviour = None)                                      # should be  = TopLevelApplicationBehaviour()    # the GUI's main loop, waiting for input events and scheduled     # actions (with after())      self.root.mainloop()  def close_all_windows(self):    for window in TopLevelWindow.topLevelWindows.keys():      window.window_close()      # should replace this by sending a "close" event to the window's behaviour Statechart  def SIGINT_signal_handler(self, signal, frame):    # TODO: send an appropriate event to the overall application's behaviour Statechart    # so it can model what to do upon SIGINT    # here, upon receiveing SIGINT, all windows are closed    print '\nClosing all windows'    self.close_all_windows()if __name__=="__main__":  commandLineArguments = sys.argv  # argv[0] is command name  # argv[1] if present is the number of windows to open  GUIapplication(commandLineArguments)